#!/bin/bash

# --- template --- {{{
readonly cf="\\033[0m"
readonly red="\\033[0;31m"
readonly green="\\033[0;32m"
readonly yellow="\\033[0;33m"

err() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${red}ERROR${cf}]: $1" 1>&2
}

warn() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${yellow}WARNING${cf}]: $1"
}

info() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][INFO]: $1 "
}

succ() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${green}SUCCESS${cf}]: $1"
}

showdate() {
  local _date
  _date=$(date +%d-%H.%M)
  echo "$_date"
}

cleanup() {
  info "cleanup.."
}
#}}}

show_help() {
  cat <<'EOF'

USAGE:
  runeflex [options] <border_char>

OPTIONS:
  -h: help
  -t: test: runeflex_test
  -m: margin size
  -x: horizontal margin size
  -y: vertical margin size
  -b: border option
  -c: display center

EXAMPLE:
EOF
}

run_runeflex() {
  local file
  local file_max
  local flie_max_before
  local max
  local line
  local lines

  local i=0
  for file in "$@"; do
    if is_exists_file "$file"; then
      file_in="$(cat "$file")"
      file_max="$(max_line_width "$file_in")"
      max=$((max + file_max))
      local j=0
      local empty_count=0
      local empty_count_before=0
      while read -r line; do
        empty_count="$((file_max - $(runewidth "$line")))"
        if [[ -z ${lines[j]} ]]; then
          empty_count_before="$((flie_max_before))"
        fi
        if [[ $empty_count_before -ne 0 ]]; then
          empty_count_before=$((empty_count_before + BOX_MARGIN_X))
        fi
        if [[ "$#" -eq $((i + 1)) ]]; then
          if [[ $BOX_CHAR_RUNEWIDTH -eq 0 ]]; then
            lines[j]="$(repeat_string ' ' "$empty_count_before")${lines[j]}$line"
          fi
        else
          lines[j]="$(repeat_string ' ' "$empty_count_before")${lines[j]}$line$(repeat_string ' ' "$BOX_MARGIN_X")$(repeat_string ' ' "$empty_count")"
        fi
        ((j++))
      done <<<"$file_in"
    else
      err_exit "$file file is not found" "$ERR_CODE_NOT_FOUND_INPUT_FILE"
    fi
    flie_max_before="$file_max"
    ((i++))
  done

  line=""
  for line in "${lines[@]}"; do
    echo "$line"
  done
}

max_line_width() {
  local max
  local lines
  local l
  while read -r l; do
    if [[ $(runewidth "$l") -gt $max ]]; then
      max=$(runewidth "$l")
    fi
    lines+=("$l")
  done <<<"$1"
  printf "%d" "$max"
}

repeat_string() {
  local i
  if [[ 0 -ne $2 ]]; then
    for ((i = 1; i <= $2; i++)); do
      printf "%s" "$1"
    done
  fi
}

empty_block() {
  printf ' '
}

front_margin_block() {
  printf "%s" "$1"
  repeat_string ' ' "$2"
}

back_margin_block() {
  repeat_string ' ' "$2"
  printf "%s" "$1"
}

border_line() {
  repeat_string "$1" "$2"
}

new_line() {
  printf "\n"
}

empty_frame_line() {
  printf "%s" "$1"
  repeat_string ' ' "$2"
  printf "%s" "$1"
}

tab_to_space() {
  # shellcheck disable=SC2001
  echo "$1" | sed -e 's/\t/    /g'
}

is_pipe() {
  if [ -p /dev/stdin ]; then
    return 0
  elif [ -p /dev/stdout ]; then
    return 0
  else
    return 1
  fi
}

is_exists() {
  which "$1" >/dev/null 2>&1
  return $?
}

is_exists_file() {
  if [[ -e "$1" ]]; then
    return 0
  else
    return 1
  fi
}

is_number() {
  if [[ "$1" =~ ^[0-9]+$ ]]; then
    return 0
  else
    return 1
  fi
}

err_exit() {
  err "$1"
  if [[ -z "$2" ]]; then
    exit 1
  else
    exit "$2"
  fi
}

exit_health() {
  if [[ -n "$1" ]]; then
    info "$1"
  fi
  exit 0
}

exit_quit() {
  err "quit" 1>&2
  exit 1
}

# locale
export LC_ALL=C

# IFS
IFS=""

# trap
trap exit_quit QUIT SIGINT

# vars
BOX_MARGIN_X=2
BOX_MARGIN_Y=0
BORDER_CHAR=""
BOX_CHAR_RUNEWIDTH=0
TEST_FILE="./runeflex_test"
POSITIONAL_ARGS=()

## error code
ERR_CODE_INVALID_OPTION=3
ERR_CODE_INVALID_BOX_CHAR_WIDTH=4
ERR_CODE_NOT_FOUND_RUNEWIDTH=5
ERR_CODE_NOT_FOUND_INPUT_FILE=6
ERR_CODE_NOT_FOUND_TESTFILE=7

while [[ $# -gt 0 ]]; do
  case $1 in
  -h | --help)
    show_help
    exit_health ""
    ;;
  -t | --test)
    if [ -f "$TEST_FILE" ]; then
      info "start testing"
      # shellcheck disable=SC1090
      . "$TEST_FILE"
      info "end testing"
    else
      err_exit "$TEST_FILE file is not found" "$ERR_CODE_NOT_FOUND_TESTFILE"
    fi
    exit_health ""
    shift # past argument
    shift # past value
    ;;
  -c | --center)
    if is_number "$2"; then
      BOX_MARGIN_X="$2"
      BOX_MARGIN_Y="$2"
    else
      err_exit "--margin option argument is expected the number" "$ERR_CODE_INVALID_OPTION"
    fi
    shift # past argument
    shift # past value
    ;;
  -m | --margin)
    if is_number "$2"; then
      BOX_MARGIN_X="$2"
      BOX_MARGIN_Y="$2"
    else
      err_exit "--margin option argument is expected the number" "$ERR_CODE_INVALID_OPTION"
    fi
    shift # past argument
    shift # past value
    ;;
  -mx | --margin-x)
    if is_number "$2"; then
      BOX_MARGIN_X="$2"
    else
      err_exit "--margin-x option argument is expected the number" "$ERR_CODE_INVALID_OPTION"
    fi
    shift # past argument
    shift # past value
    ;;
  -my | --margin-y)
    if is_number "$2"; then
      BOX_MARGIN_Y="$2"
    else
      err_exit "--margin-y option argument is expected the number" "$ERR_CODE_INVALID_OPTION"
    fi
    shift # past argument
    shift # past value
    ;;
  -b | --border)
    if [[ -$(runewidth "$2") -lt 3 ]]; then
      BORDER_CHAR="$2"
    else
      err_exit "--border option argument is expected the number" "$ERR_CODE_INVALID_OPTION"
    fi
    shift
    shift
    ;;
  -* | --*)
    err_exit "Invalid option" "$ERR_CODE_INVALID_OPTION"
    break
    ;;
  *)
    POSITIONAL_ARGS+=("$1") # save positional arg
    shift                   # past argument
    ;;
  esac
done

# restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

# fix box char runewidth
BOX_CHAR_RUNEWIDTH="$(runewidth "$BORDER_CHAR")"

# validation
if [[ -z "$BOX_CHAR_RUNEWIDTH" || "$BOX_CHAR_RUNEWIDTH" -gt 2 ]]; then
  err_exit "String is over 2 runewidth" "$ERR_CODE_INVALID_BOX_CHAR_WIDTH"
elif ! is_exists "runewidth"; then
  err_exit "Command not found: runewidth" "$ERR_CODE_NOT_FOUND_RUNEWIDTH"
else
  out="$(run_runeflex "$@")"
  echo "$out"
fi
